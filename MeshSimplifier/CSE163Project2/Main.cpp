#include <iostream>
#include <string>
#include <sstream>
#include "Dependencies/glm/glm.hpp"
#include "Dependencies/glm/gtc/matrix_transform.hpp"
#include "Dependencies/glew/glew.h"
#include "Dependencies/glut/glut.h"
#include "Shader.h"
#include "MeshObject.h"
#include <cstdio>
#include <ctime>


typedef glm::vec3 vec3;
typedef glm::vec4 vec4;
typedef glm::mat3x3 mat3x3;
typedef glm::mat4x4 mat4x4;

//ADJUSTABLE VARIABLES FOR DEBUGG
std::string name;
const char* PATH_TO_OFF_FILE;
float fovy = 70.0f * glm::pi<float>() / 180.0f;

//Variables for Shaders
GLuint defaultVAO, defaultVBO, defaultNBO, defaultEBO, defaultCBO;
GLuint vertexshader, fragmentshader, shaderprogram;

MeshObject *object;

// Constants to set up lighting
const vec4 light_position(0, 5, 5, 1);    // Position of light 0
const vec4 light_position1(0, 0, 0, 1);  // Position of light 1
const vec4 light_position2(0, 0, 0, 1);   //Position of 1ight 2
const vec4 light_specular(0.7, 0.6, .2, 1);    // Specular of light 0
const vec4 light_specular1(.4, 0.7, 1, 1);   // Specular of light 1
const vec4 light_specular2(.8, 0.4, 0.3, 1);   // Specular of light 1
const vec4 one(0.5, 0.5, 0.5, 1);                 // Specular 
const vec4 medium(0.5, 0.5, 0.5, 1);        // Diffuse 
const vec4 small(0.2, 0.2, 0.2, 1);         // Ambient 
const vec4 colorValues(1.0, 0, 0, 0);
const GLfloat high = 300;                      // Shininess of teapot
vec4 light0, light1, light2;

// Variables to set uniform params for lighting fragment shader 
GLuint islight;
GLuint light0posn;
GLuint light0color;
GLuint light1posn;               
GLuint light1color;
GLuint light2posn;
GLuint light2color;
GLuint ambient;
GLuint diffuse;
GLuint specular;
GLuint shininess;
GLuint color;

int w = 500, h = 500;
enum { rot, trans, moveCam, simplify} transop; // which operation to transform 
float tx, ty;
int amount = 10;
const float pi = 3.1415926f;
bool lightONOFF = false;

//translation, scale matrix
mat4x4 tr, sc;
//total transformed modelview matrix
mat4x4 transf;

vec3 eye; // The (regularly updated) vector coordinates of the eye location 
vec3 up;  // The (regularly updated) vector coordinates of the up location 
const vec3 eyeinit(0.0, 0.0, 7.0); // Initial eye position, also for resets
const vec3 upinit(0.0, 1.0, 0.0); // Initial up position, also for resets
const int amountinit = 5; //Initial step amount for camera movement, also for resets

// Uniform variables used for the transformation matrices
GLuint projectionPos, modelviewPos;
mat4x4 projection, modelview;

// Initialize the buffer objects. Can only be called after OpenGL is initialized.
void initBufferObjects() {
	// Tell OpenGL to allocate us some space for the VAO
	glGenVertexArrays(1, &defaultVAO);
	// Now allocate some space for all the buffer objects
	glGenBuffers(1, &defaultVBO);
	glGenBuffers(1, &defaultNBO);
	glGenBuffers(1, &defaultEBO);
	glGenBuffers(1, &defaultCBO);
}

// Free up any dynamically allocated memory here
void destroyBufferObjects() {
	// Delete every vertex array and buffer generated by OpenGL
	glDeleteVertexArrays(1, &defaultVAO);
	glDeleteBuffers(1, &defaultVBO);
	glDeleteBuffers(1, &defaultNBO);
	glDeleteBuffers(1, &defaultEBO);
	glDeleteBuffers(1, &defaultCBO);
}

// Deallocate any dynamically allocated memory here
void cleanup() {
	destroyBufferObjects();
}

//Custom translation method
mat4x4 translate(const float &tx, const float &ty, const float &tz)
{
	mat4x4 ret(1.0f);
	ret[3][0] = tx;
	ret[3][1] = ty;
	ret[3][2] = tz;
	return ret;
}

//Custom scale method
mat4x4 scale(const float &sx, const float &sy, const float &sz)
{
	mat4x4 ret(1.0f);
	ret[0][0] = sx;
	ret[1][1] = sy;
	ret[2][2] = sz;
	return ret;
}

void initialize() {

	object = new MeshObject(PATH_TO_OFF_FILE);
	eye = eyeinit;
	up = upinit;

	glEnable(GL_DEPTH_TEST);
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	vertexshader = initshaders(GL_VERTEX_SHADER, "shaders/light.vert.glsl");
	fragmentshader = initshaders(GL_FRAGMENT_SHADER, "shaders/light.frag.glsl");
	shaderprogram = initprogram(vertexshader, fragmentshader);
	islight = glGetUniformLocation(shaderprogram, "islight");
	light0posn = glGetUniformLocation(shaderprogram, "light0posn");
	light0color = glGetUniformLocation(shaderprogram, "light0color");
	light1posn = glGetUniformLocation(shaderprogram, "light1posn");
	light1color = glGetUniformLocation(shaderprogram, "light1color");
	light2posn = glGetUniformLocation(shaderprogram, "light2posn");
	light2color = glGetUniformLocation(shaderprogram, "light2color");
	ambient = glGetUniformLocation(shaderprogram, "ambient");
	diffuse = glGetUniformLocation(shaderprogram, "diffuse");
	specular = glGetUniformLocation(shaderprogram, "specular");
	shininess = glGetUniformLocation(shaderprogram, "shininess");
	color = glGetUniformLocation(shaderprogram, "color");

	// Get the uniform locations of the transformation matrices
	projectionPos = glGetUniformLocation(shaderprogram, "projection");
	modelviewPos = glGetUniformLocation(shaderprogram, "modelview");

	// Other initializations here
	initBufferObjects();
	object->modelviewPos = modelviewPos;
	object->modelview = modelview;
}

// New helper transformation function to transform vector by the view matrix
void transformvec(const vec4 input, vec4& output) {
	output = modelview * input;
}

// This function gets called when the window size gets changed
void reshape(int width, int height) {
	w = width;
	h = height;
	glViewport(0, 0, w, h);
	projection = glm::perspective(fovy, (float)w / (float)h, 0.01f, 100.0f);
	glUniformMatrix4fv(projectionPos, 1, GL_FALSE, &projection[0][0]);
}

void display() {
	glClearColor(0, 0, 1, 0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	const vec3 center(0, 0, 0);
	modelview = glm::lookAt(eye, center, up);

	// Set Light and Material properties 
	// Lights are transformed by current modelview matrix. 
	// The shader can't do this globally. 
	// So we need to do so manually.  
	transformvec(light_position, light0);
	transformvec(light_position1, light1);
	glUniform4fv(light0posn, 1, &light0[0]);
	glUniform4fv(light0color, 1, &light_specular[0]);
	glUniform4fv(light1posn, 1, &light1[0]);
	glUniform4fv(light1color, 1, &light_specular1[0]);
	glUniform4fv(light2posn, 1, &light2[0]);
	glUniform4fv(light2color, 1, &light_specular2[0]);//////////////////////////////////////////////////////////implement quadratics

	glUniform4fv(ambient, 1, &small[0]);
	glUniform4fv(diffuse, 1, &small[0]);
	glUniform4fv(specular, 1, &one[0]);
	glUniform1f(shininess, high);
	glUniform4fv(color, 1, &colorValues[0]); 
	glUniform1i(islight, lightONOFF);

	mat4x4 sc(1.0), tr(1.0), transf(1.0);
	tr = translate(tx, ty, 0.0);
	sc = scale(1.0f / object->norm(), 1.0f / object->norm(), 1.0f / object->norm());
	transf = sc * tr * modelview;

	object->modelview = transf;
	object->drawObject(defaultVAO, defaultVBO, defaultEBO, defaultNBO, defaultCBO);
	glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) {
	std::string input1, input2;
	int v1, v2;
	int numIterations;
	switch (key) {
	case 27:  // Escape to quit
		exit(0);
		break;
	case 's': // reset eye and up vectors, scale and translate. 
		eye = eyeinit;
		up = upinit;
		tx = ty = 0.0;
		transop = rot;
		break;
	case 'r':
		transop = rot;
		//std::cout << "Operation is set to View\n";
		break;
	case 't':
		transop = trans;
		//std::cout << "Operation is set to Translate\n";
		break;
	case 'e':
		transop = moveCam;
		//std::cout << "Operation is set to move camera\n";
		break;
	case 'l':
		if (lightONOFF) {
			lightONOFF = false;
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		}
		else {
			lightONOFF = true;
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		}
		break;
	case 'q':
		transop = simplify;
		break;
	case 'i':
		std::cout << "insert vertex 1 : ";
		std::cin >> v1;
		std::cout << "insert vertex 2 : ";
		std::cin >> v2;
		object->edgeCollapse(v1, v2);
		break;
	}
	glutPostRedisplay();
}

mat3x3 rotate(const float degrees, const vec3& axis) {
	mat3x3 ret;  
	double rad = (degrees * pi) / 180.0;
	glm::mat3 mat1(1 * cos(rad), 0, 0,
		0, 1 * cos(rad), 0,
		0, 0, 1 * cos(rad));
	double v = 1 - cos(rad);
	glm::mat3 mat2(axis.x * axis.x * v, axis.x * axis.y * v, axis.x * axis.z * v,
		axis.x * axis.y * v, axis.y * axis.y * v, axis.y * axis.z * v,
		axis.x * axis.z * v, axis.y * axis.z * v, axis.z * axis.z * v);
	glm::mat3 mat3(0, axis.z * sin(rad), -axis.y * sin(rad),
		-axis.z * sin(rad), 0, axis.x * sin(rad),
		axis.y * sin(rad), -axis.x * sin(rad), 0);
	ret = mat1 + mat2 + mat3;
	return ret;
}

void left(float degrees, vec3& eye, vec3& up)
{
	eye = rotate(degrees, glm::normalize(up)) * eye;
	up = rotate(degrees, glm::normalize(up)) * up;
}

void turnUp(float degrees, vec3& eye, vec3& up)
{
	glm::vec3 axis = glm::cross(up, eye);
	glm::vec3 newAxis = glm::normalize(axis);
	eye = rotate(-degrees, newAxis) * eye;
	up = rotate(-degrees, newAxis) * up;
}

void specialKey(int key, int x, int y) {
	switch (key) {
	case 100: //left
		if (transop == rot) left(amount, eye, up);
		else if (transop == trans) tx -= amount * 0.125;
		break;
	case 101: //up
		if (transop == rot) turnUp(-amount, eye, up);
		else if (transop == moveCam) {
			vec3 move = eye * 0.1;
			eye = eye - move;
		}
		else if (transop == trans) ty += amount * 0.125;
		else if (transop == simplify) {
			std::clock_t start;
			double duration;
			start = std::clock();
			std::cout << "starting simplification" << std::endl;
			object->quadricSimplification();
			duration = (std::clock() - start) / (double)CLOCKS_PER_SEC;
			std::cout << "done simplifying : " << duration << std::endl;
		}
		break;
	case 102: //right
		if (transop == rot) left(-amount, eye, up);
		else if (transop == trans) tx += amount * 0.125;
		break;
	case 103: //down
		if (transop == rot) turnUp(amount, eye, up);
		else if (transop == moveCam) {
			vec3 move = eye * 0.1;
			eye = eye + move;
		}
		else if (transop == trans) ty -= amount * 0.125;
		else if (transop == simplify) {
			std::clock_t start;
			double duration;
			start = std::clock();
			std::cout << "starting unsimplification" << std::endl;
			object->quadricUnsimplification();
			duration = (std::clock() - start) / (double)CLOCKS_PER_SEC;
			std::cout << "done unsimplifying : " << duration << std::endl;
		}
		break;
	}
	glutPostRedisplay();
}

void instructions() {
	std::cout << "press 't' to translate object (up, down, left, right)" << std::endl;
	std::cout << "press 'e' to move camera in and out (up, down)" << std::endl;
	std::cout << "press 'r' to rotate object (up, down, left, right)" << std::endl;
	std::cout << "press 's' to reset object" << std::endl;
	std::cout << "press 'l' to toggle between wire mesh and shaded polygon mode" << std::endl;
	std::cout << "press 'q' simplify/unsimplify mesh (up, down)" << std::endl;
	std::cout << "press 'i' to perform an edge collapse between two specific vertices" << std::endl;
	std::cout << std::endl;
	std::cout << "CAUTION : If wrong filepath is specified, or if file is not of type .OFF, program will crash" << std::endl;;
	std::cout << std::endl;
	std::cout << "input file name : ";
	std::cin >> name;
	PATH_TO_OFF_FILE = name.c_str();
}

int main(int argc, char* argv[]) {

	instructions();
	//initialize GLUT
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);
	glutCreateWindow("CSE163 - Homework 2");

	GLenum err = glewInit();
	if (GLEW_OK != err) {
		std::cerr << "Error: " << glewGetString(err) << std::endl;
	}

	initialize();
	glutSpecialFunc(specialKey);
	glutKeyboardFunc(keyboard);
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutReshapeWindow(w, h);
	glutMainLoop();
	cleanup();
	return 0;
}