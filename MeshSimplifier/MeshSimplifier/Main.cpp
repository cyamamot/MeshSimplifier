#include <iostream>
#include <string>
#include <sstream>
#include "Dependencies/glm/glm.hpp"
#include "Dependencies/glm/gtc/matrix_transform.hpp"
#include "Dependencies/glew/glew.h"
#include "Dependencies/glut/glut.h"
#include "Shader.h"
#include "MeshObject.h"
#include <cstdio>
#include <ctime>


typedef glm::vec3 vec3;
typedef glm::vec4 vec4;
typedef glm::mat3x3 mat3x3;
typedef glm::mat4x4 mat4x4;

std::string name;
const char* PATH_TO_OFF_FILE;
float fovy = 70.0f * glm::pi<float>() / 180.0f;
//used for rotating mesh
vec3 LastPoint;
//used for zooming in/out of mesh
int LastScreenPoint;

//Variables for Shaders
GLuint defaultVAO, defaultVBO, defaultNBO, defaultEBO, defaultCBO;
GLuint vertexshader, fragmentshader, shaderprogram;

MeshObject *object = NULL;

// Constants to set up lighting
const vec4 light_position(0, 5, 5, 1);    // Position of light 0
const vec4 light_position1(0, 0, 0, 1);  // Position of light 1
const vec4 light_position2(0, 0, 0, 1);   //Position of 1ight 2
const vec4 light_specular(0.7, 0.6, .2, 1);    // Specular of light 0
const vec4 light_specular1(.4, 0.7, 1, 1);   // Specular of light 1
const vec4 light_specular2(.8, 0.4, 0.3, 1);   // Specular of light 1
const vec4 one(0.5, 0.5, 0.5, 1);                 // Specular 
const vec4 medium(0.5, 0.5, 0.5, 1);        // Diffuse 
const vec4 small(0.2, 0.2, 0.2, 1);         // Ambient 
const vec4 colorValues(1.0, 0, 0, 0);
const GLfloat high = 300;                      // Shininess 
vec4 light0, light1, light2;

// Variables to set uniform params for lighting fragment shader 
GLuint islight;
GLuint light0posn;
GLuint light0color;
GLuint light1posn;               
GLuint light1color;
GLuint light2posn;
GLuint light2color;
GLuint ambient;
GLuint diffuse;
GLuint specular;
GLuint shininess;
GLuint color;

int w = 500, h = 500;
enum { trans, simplify } mode; // which operation to transform 
//amount to translate by
float tx, ty;
const float pi = 3.1415926f;
bool lightONOFF = false;

//translation, scale matrix
mat4x4 tr;
//total transformed modelview matrix
mat4x4 transf;

vec3 eye; // The (regularly updated) vector coordinates of the eye location 
vec3 up;  // The (regularly updated) vector coordinates of the up location 
const vec3 center(0, 0, 0);
const vec3 eyeinit(10.0, 0.0, 0.0); // Initial eye position, also for resets
const vec3 upinit(0.0, 1.0, 0.0); // Initial up position, also for resets
const int amountinit = 5; //Initial step amount for camera movement, also for resets

// Uniform variables used for the transformation matrices
GLuint projectionPos, modelviewPos;
mat4x4 projection, modelview;

// Initialize the buffer objects. Can only be called after OpenGL is initialized.
void initBufferObjects() 
{
	// Tell OpenGL to allocate us some space for the VAO
	glGenVertexArrays(1, &defaultVAO);
	// Now allocate some space for all the buffer objects
	glGenBuffers(1, &defaultVBO);
	glGenBuffers(1, &defaultNBO);
	glGenBuffers(1, &defaultEBO);
	glGenBuffers(1, &defaultCBO);
}

// Free up any dynamically allocated memory here
void destroyBufferObjects() 
{
	// Delete every vertex array and buffer generated by OpenGL
	glDeleteVertexArrays(1, &defaultVAO);
	glDeleteBuffers(1, &defaultVBO);
	glDeleteBuffers(1, &defaultNBO);
	glDeleteBuffers(1, &defaultEBO);
	glDeleteBuffers(1, &defaultCBO);
}

// Deallocate any dynamically allocated memory here
void cleanup()
{
	destroyBufferObjects();
}

//Custom translation method
mat4x4 translate(const float &tx, const float &ty, const float &tz)
{
	mat4x4 ret(1.0f);
	ret[3][0] = tx;
	ret[3][1] = ty;
	ret[3][2] = tz;
	return ret;
}

//custom rotate matrix method
mat3x3 rotate(const float degrees, const vec3& axis)
{
	mat3x3 ret;
	if ((degrees != 0) && (axis[0] != NAN) && (axis[1] != NAN) && (axis[2] != NAN))
	{
		double rad = (degrees * pi) / 180.0;
		glm::mat3 mat1(1 * cos(rad), 0, 0,
			0, 1 * cos(rad), 0,
			0, 0, 1 * cos(rad));
		double v = 1 - cos(rad);
		glm::mat3 mat2(axis.x * axis.x * v, axis.x * axis.y * v, axis.x * axis.z * v,
			axis.x * axis.y * v, axis.y * axis.y * v, axis.y * axis.z * v,
			axis.x * axis.z * v, axis.y * axis.z * v, axis.z * axis.z * v);
		glm::mat3 mat3(0, axis.z * sin(rad), -axis.y * sin(rad),
			-axis.z * sin(rad), 0, axis.x * sin(rad),
			axis.y * sin(rad), -axis.x * sin(rad), 0);
		ret = mat1 + mat2 + mat3;
	}
	return ret;
}

void initialize() 
{
	object = new MeshObject(PATH_TO_OFF_FILE);
	eye = eyeinit;
	up = upinit;
	glEnable(GL_DEPTH_TEST);
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	vertexshader = InitializeShaders(GL_VERTEX_SHADER, "shaders/light.vert.glsl");
	fragmentshader = InitializeShaders(GL_FRAGMENT_SHADER, "shaders/light.frag.glsl");
	shaderprogram = InitializeProgram(vertexshader, fragmentshader);
	islight = glGetUniformLocation(shaderprogram, "islight");
	light0posn = glGetUniformLocation(shaderprogram, "light0posn");
	light0color = glGetUniformLocation(shaderprogram, "light0color");
	light1posn = glGetUniformLocation(shaderprogram, "light1posn");
	light1color = glGetUniformLocation(shaderprogram, "light1color");
	light2posn = glGetUniformLocation(shaderprogram, "light2posn");
	light2color = glGetUniformLocation(shaderprogram, "light2color");
	ambient = glGetUniformLocation(shaderprogram, "ambient");
	diffuse = glGetUniformLocation(shaderprogram, "diffuse");
	specular = glGetUniformLocation(shaderprogram, "specular");
	shininess = glGetUniformLocation(shaderprogram, "shininess");
	color = glGetUniformLocation(shaderprogram, "color");

	// Get the uniform locations of the transformation matrices
	projectionPos = glGetUniformLocation(shaderprogram, "projection");
	modelviewPos = glGetUniformLocation(shaderprogram, "modelview");

	// Other initializations here
	initBufferObjects();
	object->modelviewPos = modelviewPos;
	object->modelview = modelview;
}

// New helper transformation function to transform vector by the view matrix
void transformvec(const vec4 input, vec4& output) 
{
	output = modelview * input;
}

// This function gets called when the window size gets changed
void reshape(int width, int height)
{
	w = width;
	h = height;
	glViewport(0, 0, w, h);
	projection = glm::perspective(fovy, (float)w / (float)h, 0.01f, 100.0f);
	glUniformMatrix4fv(projectionPos, 1, GL_FALSE, &projection[0][0]);
}

void display() 
{
	glClearColor(0, 0, 1, 0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	modelview = glm::lookAt(eye, center, up);
 
	transformvec(light_position, light0);
	transformvec(light_position1, light1);
	glUniform4fv(light0posn, 1, &light0[0]);
	glUniform4fv(light0color, 1, &light_specular[0]);
	glUniform4fv(light1posn, 1, &light1[0]);
	glUniform4fv(light1color, 1, &light_specular1[0]);
	glUniform4fv(light2posn, 1, &light2[0]);
	glUniform4fv(light2color, 1, &light_specular2[0]);

	glUniform4fv(ambient, 1, &small[0]);
	glUniform4fv(diffuse, 1, &small[0]);
	glUniform4fv(specular, 1, &one[0]);
	glUniform1f(shininess, high);
	glUniform4fv(color, 1, &colorValues[0]); 
	glUniform1i(islight, lightONOFF);

	//perfomrs user specified scaling/translation on mesh
	mat4x4 sc(1.0), tr(1.0), transf(1.0);
	tr = translate(tx, ty, 0.0);
	transf = tr * modelview;

	object->modelview = transf;
	object->drawObject(defaultVAO, defaultVBO, defaultEBO, defaultNBO, defaultCBO);
	glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y) 
{
	std::string input1, input2;
	switch (key) {
	case 27:  // Escape to quit
		exit(0);
		break;
	case 's': // reset eye and up vectors, and translate. 
		eye = eyeinit;
		up = upinit;
		tx = ty = 0.0;
		mode = trans;
		break;
	case 't':
		mode = trans;
		//std::cout << "Operation is set to Translate\n";
		break;
	case 'l':
		if (lightONOFF) {
			lightONOFF = false;
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		}
		else {
			lightONOFF = true;
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
		}
		break;
	case 'q':
		mode = simplify;
	}
	glutPostRedisplay();
}

vec3 MapTrackBall(int x, int y) 
{
	vec3 NewPoint;
	float dist;
	NewPoint[0] = (2.0f * x - glutGet(GLUT_WINDOW_WIDTH)) / glutGet(GLUT_WINDOW_WIDTH);
	NewPoint[1] = (glutGet(GLUT_WINDOW_HEIGHT) - 2.0f * y) / glutGet(GLUT_WINDOW_HEIGHT);
	NewPoint[2] = 0;
	dist = (glm::distance(NewPoint, center) < 1.0f) ? glm::distance(NewPoint, center) : 1.0f;
	NewPoint[2] = sqrt(1.001f - dist * dist);
	NewPoint = glm::normalize(NewPoint);
	return NewPoint;
}

void TrackBall(int x, int y) 
{
	vec3 NewPoint = MapTrackBall(x, y);
	vec3 axis = glm::cross(NewPoint, LastPoint);
	axis = glm::normalize(axis);
	vec4 newaxis = { axis[0], axis[1], axis[2], 0.0f };
	newaxis = glm::inverse(modelview) * newaxis;
	axis = { newaxis[0], newaxis[1], newaxis[2] };
	float angle = 50.0f * glm::distance((NewPoint - LastPoint), center);
	eye = rotate(angle, axis) * eye;
	up = rotate(angle, axis) * up;
	LastPoint = NewPoint;
	glutPostRedisplay();
}

void Zoom(int x, int y)
{
	vec4 temp(0.0f, 0.0f, 0.5f, 0.0f);
	temp = glm::inverse(modelview) * temp;
	if (y > LastScreenPoint)
	{
		eye += vec3(temp[0], temp[1], temp[2]);
	}
	else if (y < LastScreenPoint)
	{
		eye -= vec3(temp[0], temp[1], temp[2]);
	}
	LastScreenPoint = y;
	glutPostRedisplay();
}

void WhichButton(int button, int state, int x, int y)
{
	if (state == GLUT_DOWN) 
	{
		if (button == GLUT_LEFT_BUTTON)
		{
			glutMotionFunc(TrackBall);
		}
		if (button == GLUT_RIGHT_BUTTON)
		{
			glutMotionFunc(Zoom);
		}
	}
}

void WatchMouse(int x, int y) 
{
	LastPoint = MapTrackBall(x, y);
	LastScreenPoint = y;
}

void specialKey(int key, int x, int y) 
{
	switch (key) {
	case 100: //left
		if (mode == trans) tx -= 1.0f;
		break;
	case 101: //up
		if (mode == trans) ty += 1.0f;
		else if (mode == simplify) 
		{
			std::clock_t start;
			double duration;
			start = std::clock();
			std::cout << "starting simplification" << std::endl;
			object->quadricSimplification();
			duration = (std::clock() - start) / (double)CLOCKS_PER_SEC;
			std::cout << "done simplifying : " << duration << std::endl;
		}
		break;
	case 102: //right
		if (mode == trans) tx += 1.0f;
		break;
	case 103: //down
		if (mode == trans) ty -= 1.0f;
		else if (mode == simplify) 
		{
			std::clock_t start;
			double duration;
			start = std::clock();
			std::cout << "starting unsimplification" << std::endl;
			object->quadricUnsimplification();
			duration = (std::clock() - start) / (double)CLOCKS_PER_SEC;
			std::cout << "done unsimplifying : " << duration << std::endl;
		}
		break;
	}
	glutPostRedisplay();
}

void instructions()
{
	std::cout << "Rotate mesh by holding down left mouse button and dragging" << std::endl;
	std::cout << "Zoom in/out of mesh by holding down right mouse button and dragging up or down" << std::endl;
	std::cout << "press 't' to translate object (up, down, left, right)" << std::endl;
	std::cout << "press 's' to reset object" << std::endl;
	std::cout << "press 'l' to toggle between wire mesh and shaded polygon mode" << std::endl;
	std::cout << "press 'q' simplify/unsimplify mesh (up, down)" << std::endl;
	std::cout << std::endl;
	std::cout << "CAUTION : If wrong filepath is specified, or if file is not of type .OFF, program will crash" << std::endl;;
	std::cout << std::endl;
	std::cout << "input file name : ";
	std::cin >> name;
	PATH_TO_OFF_FILE = name.c_str();
}

int main(int argc, char* argv[])
{
	instructions();
	//initialize GLUT
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);
	glutCreateWindow("MeshSimplifier");

	GLenum err = glewInit();
	if (GLEW_OK != err)
	{
		std::cerr << "Error: " << glewGetString(err) << std::endl;
	}
	initialize();
	glutSpecialFunc(specialKey);
	glutKeyboardFunc(keyboard);
	glutMouseFunc(WhichButton);
	glutPassiveMotionFunc(WatchMouse);
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutReshapeWindow(w, h);
	glutMainLoop();
	cleanup();
	return 0;
}